//opencv
#include <opencv2/core/core.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
cv::BackgroundSubtractorMOG pMOG; //MOG Background subtractor
cv::BackgroundSubtractorMOG2 pMOG2; //MOG2 Background subtractor
std::vector<std::vector<cv::Point> > contours;
int keyboard;
int thresh = 100;
RNG rng(12345);

//function declarations
void processVideo(std::string videoFilename);

int main(int argc, char* argv[])
{

	//create GUI windows
	namedWindow("Frame", WINDOW_NORMAL);
	resizeWindow("Frame", 300,250);

	namedWindow("FG Mask MOG", WINDOW_NORMAL);
	resizeWindow("FG Mask MOG", 300,250);

	namedWindow("FG Mask MOG 2", WINDOW_NORMAL);
	resizeWindow("FG Mask MOG 2", 300,250);

	processVideo(argv[1]);

	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {


	VideoCapture capture(videoFilename); //try to open string, this will attempt to open it as a video file

	if (!capture.isOpened()) //if this fails, try to open as a video camera, through the use of an integer param
	{
		capture.open(atoi(videoFilename.c_str()));
	}

	if (!capture.isOpened())
	{
		cerr << "Failed to open a video device or video file!\n" << endl;
	}

    //read input data. ESC or 'q' for quitting
    for(;;){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        //update the background model
           //AND HERE!!!
        pMOG(frame, fgMaskMOG);
        pMOG2(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        stringstream ss;
        ss << capture.get(CV_CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();

        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
        keyboard = waitKey( 30 );
        Mat threshold_output;
        vector<vector<Point> > contours;
        vector<Vec4i> hierarchy;


        cv::dilate(fgMaskMOG,fgMaskMOG,cv::Mat());
        cv::dilate(fgMaskMOG,fgMaskMOG,cv::Mat());

        /// Detect edges using Threshold
        threshold( fgMaskMOG, threshold_output, thresh, 255, THRESH_BINARY );
        /// Find contours
        findContours( threshold_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

        /// Approximate contours to polygons + get bounding rects and circles
        vector<vector<Point> > contours_poly( contours.size() );
        vector<Rect> boundRect( contours.size() );

        for( unsigned int i = 0; i < contours.size(); i++ )
           { approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );
             boundRect[i] = boundingRect( Mat(contours_poly[i]) );
           }
        static int count = 0;
        /// Draw polygonal contour + bonding rects + circles
        Mat drawing = Mat::zeros( threshold_output.size(), CV_8UC3 );
        for( unsigned int i = 0; i< contours.size(); i++ )
           {
             Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
             drawContours( drawing, contours_poly, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
             if (boundRect[i].area() > 5000 ){
          	   rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0 );
          	   count++;
          	   cout << count << "Number of cars........\n";
             }
             cout << boundRect[i].area() << "\n";
           }

          /// Show in a window
        imshow( "Contours", drawing );
    }
    //delete capture object
    capture.release();
}
