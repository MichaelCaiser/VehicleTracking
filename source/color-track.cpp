//opencv
#include <opencv2/core/core.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include <cvblob.h>

using namespace cv;
using namespace std;
using namespace cvb;

#define h 250
#define w 300

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
cv::BackgroundSubtractorMOG pMOG; //MOG Background subtractor
int keyboard;
CvBlobs blobs;

//function declarations
void processVideo(std::string videoFilename);

int main(int argc, char* argv[])
{

	//create GUI windows
	namedWindow("Frame", WINDOW_NORMAL);
	resizeWindow("Frame", 300, 250);

	namedWindow("FG Mask MOG", WINDOW_NORMAL);
	resizeWindow("FG Mask MOG", 300, 250);

	//namedWindow("FG Mask MOG 2", WINDOW_NORMAL);
	//resizeWindow("FG Mask MOG 2", 300,250);

	processVideo(argv[1]);

	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

void processVideo(std::string videoFilename)
{
	//create the capture object

	VideoCapture capture(videoFilename); //try to open string, this will attempt to open it as a video file

	if (!capture.isOpened()) //if this fails, try to open as a video camera, through the use of an integer param
	{
		capture.open(atoi(videoFilename.c_str()));
	}

	if (!capture.isOpened())
	{
		cerr << "Failed to open a video device or video file!\n" << endl;
	}

	IplImage*labelImg = cvCreateImage(cvSize(w, h), (int) IPL_DEPTH_LABEL, 1); //Image Variable for blobs

	//read input data. ESC or 'q' for quitting
	while ((char) keyboard != 'q' && (char) keyboard != 27)
	{
		//read the current frame
		if (!capture.read(frame))
		{
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit (EXIT_FAILURE);
		}
		//update the background model
		//AND HERE!!!
		pMOG(frame, fgMaskMOG, -5);

		line(frame, Point(w / 2, 0), Point(w / 2, h), Scalar(255, 0, 0), 2);

		IplImage img = fgMaskMOG;
		cvSmooth(&img, &img, CV_MEDIAN, 7, 7);
		cvLabel(&img, labelImg, blobs);

		IplImage frame2 = frame;
		cvRenderBlobs(labelImg, blobs, &frame2, &frame2, CV_BLOB_RENDER_BOUNDING_BOX);
		cvFilterByArea(blobs, 500, 1000000);
		static int count = 0;

		for (CvBlobs::const_iterator it = blobs.begin(); it != blobs.end(); ++it)
		{
			double moment10 = it->second->m10;
			double moment01 = it->second->m01;
			double area = it->second->area;
			//Variable for holding position
			int x1;
			int y1;
			//Calculating the current position
			x1 = moment10 / area;
			y1 = moment01 / area;
			//Mapping to the screen coordinates
//			int x = (int) (x1 * screenx / w);
//			int y = (int) (y1 * screeny / h);
			//Printing the position information
			cout << "X: " << x1 << " Y: " << y1 << " Area: " << area << endl;

			if (x1 > w / 2 && x1 < w / 2 + 10)
			{
				count++;
				line(frame, Point(w / 2, 0), Point(w / 2, h), Scalar(0, 255, 0), 2);
				cout << "Vehicle count" << count << "\n";
			}
		}

		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("FG Mask MOG", fgMaskMOG);
		//imshow("FG Mask MOG 2", fgMaskMOG2);

		//get the input from the keyboard
		keyboard = waitKey(30);
	}
	//delete capture object
	capture.release();
}
