//opencv
#include <opencv2/core/core.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables

Mat fgMaskMOG; //fg mask generated by MOG method
cv::BackgroundSubtractorMOG pMOG; //MOG Background subtractor
std::vector<std::vector<cv::Point> > contours;
int keyboard;
int ccount;
#define w 320
#define h 250
//function declarations
void processVideo(Mat& frame);

int main(int argc, char* argv[])
{

	IplImage* frame;
	CvCapture* capture;
	if (argc == 1)
	{
		capture = cvCreateCameraCapture(-1);
	}
	else
	{
		capture = cvCreateFileCapture(argv[1]);
	}
	cvSetCaptureProperty(capture, CV_CAP_PROP_FRAME_WIDTH, 640);
	cvSetCaptureProperty(capture, CV_CAP_PROP_FRAME_HEIGHT, 480);
//cvNamedWindow("Webcam Preview", CV_WINDOW_AUTOSIZE);
//cvMoveWindow("Webcam Preview", 300, 200);
	time_t start, end;
	double fps, sec;
	int counter = 0;
	char k;
	time(&start);
	while (1)
	{
		frame = cvQueryFrame(capture);
		time(&end);
		++counter;
		sec = difftime(end, start);
		fps = counter / sec;
		printf("FPS = %.2f\n", fps);
		if (!frame)
		{
			printf("Error");
			break;
		}

		Mat frame2(frame);
		processVideo(frame2);

//cvShowImage("Webcam Preview", frame);
		k = cvWaitKey(10) & 0xff;
		switch (k)
		{
		case 27:
		case 'q':
		case 'Q':
			break;
		}
	}
//cvDestroyWindow("Webcam Preview");
	cvReleaseCapture(&capture);
	cout << "Total cars count: " << ccount << endl;
}

void processVideo(Mat& frame)
{

//	VideoCapture capture(videoFilename); //try to open string, this will attempt to open it as a video file
	SimpleBlobDetector::Params params;
	params.minDistBetweenBlobs = 0.0f;
	params.filterByInertia = false;
	params.filterByConvexity = false;
	params.filterByColor = false;
	params.filterByCircularity = false;
	params.filterByArea = true;
	params.minArea = 500.0f;
	params.maxArea = 1500.0f;
	SimpleBlobDetector detector(params);
	vector<cv::KeyPoint> keypoints;
//
//	if (!capture.isOpened()) //if this fails, try to open as a video camera, through the use of an integer param
//	{
//		capture.open(atoi(videoFilename.c_str()));
//	}
//
//	if (!capture.isOpened())
//	{
//		cerr << "Failed to open a video device or video file!\n" << endl;
//	}
//
//	//read input data. ESC or 'q' for quitting
//	while ((char) keyboard != 'q' && (char) keyboard != 27)
//	{
//		//read the current frame
//		if (!capture.read(frame))
//		{
//			cerr << "Unable to read next frame." << endl;
//			cerr << "Exiting..." << endl;
//			exit (EXIT_FAILURE);
//		}
	//update the background model
	//AND HERE!!!
	pMOG(frame, fgMaskMOG, -10);

	Mat dst;

	//medianBlur(fgMaskMOG, fgMaskMOG, 5);
	GaussianBlur(fgMaskMOG, dst, Size(0, 0), 5, 5);
	Mat out;
	detector.detect(dst, keypoints);
	//drawKeypoints( frame, keypoints, out, CV_RGB(255,0,0), DrawMatchesFlags::DEFAULT);

	line(frame, Point(w / 2, 0), Point(w / 2, h), Scalar(255, 0, 0), 2);
	line(frame, Point(w / 2 + 2, 0), Point(w / 2 + 2, h), Scalar(255, 0, 0), 2);

	for (vector<cv::KeyPoint>::iterator it = keypoints.begin(); it != keypoints.end(); ++it)
	{
		if ((*it).pt.x > w / 2 && (*it).pt.x < w / 2 + 9)
		{
			ccount++;
			line(frame, Point(w / 2, 0), Point(w / 2, h), Scalar(0, 255, 0), 2);
			cout << "Vehicle count" << ccount << "\n";
		}
	}

	stringstream ss;
	rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
	cv::Scalar(255,255,255), -1);
	ss << ccount;
	string frameNumberString = ss.str();
	putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
	FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

	//show the current frame and the fg masks
	imshow("Frame", frame);
	imshow("FG Mask MOG", dst);
	//imshow("FG Mask MOG 2", fgMaskMOG2);
	//get the input from the keyboard
	keyboard = waitKey(10);
	//delete capture object
}
